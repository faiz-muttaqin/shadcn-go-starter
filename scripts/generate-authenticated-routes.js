#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import chokidar from 'chokidar'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const ROUTE_TREE_FILE = path.join(__dirname, '../src/routeTree.gen.ts')
const OUTPUT_FILE = path.join(
  __dirname,
  '../backend/internal/user/authenticated_file_route.go'
)

/**
 * Parse routeTree.gen.ts and extract FileRoutesById interface
 */
function parseRouteTree(content) {
  // Find FileRoutesById interface
  const match = content.match(
    /export interface FileRoutesById\s*{([^}]+)}/s
  )

  if (!match) {
    console.error('âŒ Could not find FileRoutesById interface')
    return []
  }

  const interfaceBody = match[1]
  const routes = []

  // Extract each route line like: '/_authenticated/users/': typeof ...
  const routeLines = interfaceBody.match(/'([^']+)':\s*typeof/g)

  if (!routeLines) {
    return []
  }

  routeLines.forEach((line) => {
    const routeMatch = line.match(/'([^']+)'/)
    if (routeMatch) {
      const routeId = routeMatch[1]
      routes.push(routeId)
    }
  })

  return routes
}

/**
 * Filter and convert authenticated routes
 */
function processRoutes(routes) {
  return routes
    .filter((route) => route.includes('_authenticated'))
    .map((route) => {
      // Remove _authenticated prefix
      let converted = route.replace(/^\/_authenticated/, '')

      // Remove all remaining _authenticated segments
      converted = converted.replace(/\/_authenticated/g, '')

      // Remove route groups (parentheses) - e.g., (auth) becomes empty
      converted = converted.replace(/\/\([^)]+\)/g, '')

      // Remove underscore prefixes from segments - e.g., _settings becomes settings
      converted = converted.replace(/\/_([^/]+)/g, '/$1')

      // Remove trailing slash if not root
      if (converted !== '/' && converted.endsWith('/')) {
        converted = converted.slice(0, -1)
      }

      // If empty after removing _authenticated, set to root
      if (converted === '') {
        converted = '/'
      }

      return converted
    })
    .filter((route, index, self) => self.indexOf(route) === index) // Remove duplicates
    .sort()
}

/**
 * Generate Go file content
 */
function generateGoFile(routes) {
  const timestamp = new Date().toISOString()

  return `// Code generated by generate-authenticated-routes.js - DO NOT EDIT
// Generated at: ${timestamp}

package helper

// AuthenticatedFileRoutes contains all authenticated route paths
// These routes require user authentication to access
var AuthenticatedFileRoutes = []string{
${routes.map((r) => `\t"${r}",`).join('\n')}
}

// IsAuthenticatedRoute checks if a path is an authenticated route
func IsAuthenticatedRoute(path string) bool {
\tfor _, route := range AuthenticatedFileRoutes {
\t\tif route == path {
\t\t\treturn true
\t\t}
\t}
\treturn false
}
`
}

/**
 * Generate routes from routeTree.gen.ts
 */
function generateRoutes() {
  try {
    console.log('ðŸ” Reading routeTree.gen.ts...')

    if (!fs.existsSync(ROUTE_TREE_FILE)) {
      console.error(`âŒ File not found: ${ROUTE_TREE_FILE}`)
      return
    }

    const content = fs.readFileSync(ROUTE_TREE_FILE, 'utf-8')

    console.log('ðŸ“Š Parsing routes...')
    const allRoutes = parseRouteTree(content)
    console.log(`   Found ${allRoutes.length} total routes`)

    console.log('ðŸ” Filtering authenticated routes...')
    const authenticatedRoutes = processRoutes(allRoutes)
    console.log(`   Found ${authenticatedRoutes.length} authenticated routes`)

    console.log('ðŸ“ Generating Go file...')
    const goContent = generateGoFile(authenticatedRoutes)

    // Ensure directory exists
    const outputDir = path.dirname(OUTPUT_FILE)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    // Write file
    fs.writeFileSync(OUTPUT_FILE, goContent, 'utf-8')

    console.log(`âœ… Generated: ${OUTPUT_FILE}`)
    console.log('\nðŸ“‹ Authenticated Routes:')
    authenticatedRoutes.forEach((r) => console.log(`   ${r}`))
    console.log('')
  } catch (error) {
    console.error('âŒ Error:', error.message)
  }
}

/**
 * Watch mode
 */
function watchMode() {
  console.log('ðŸ‘€ Watching routeTree.gen.ts for changes...')
  console.log(`   ${ROUTE_TREE_FILE}\n`)

  // Initial generation
  generateRoutes()

  // Watch for changes
  const watcher = chokidar.watch(ROUTE_TREE_FILE, {
    persistent: true,
    ignoreInitial: true,
  })

  watcher.on('change', () => {
    console.log('ðŸ”„ routeTree.gen.ts changed, regenerating...\n')
    generateRoutes()
  })

  // Handle exit
  process.on('SIGINT', () => {
    console.log('\nðŸ‘‹ Stopping watcher...')
    watcher.close()
    process.exit(0)
  })
}

/**
 * Main
 */
const args = process.argv.slice(2)
const isWatch = args.includes('--watch') || args.includes('-w')

if (isWatch) {
  watchMode()
} else {
  generateRoutes()
}
